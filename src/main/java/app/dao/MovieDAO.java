package app.dao;

import app.entities.Genre;
import app.entities.Movie;
import app.utils.IDAO;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.TypedQuery;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class MovieDAO implements IDAO<Movie, Integer> {

    private final EntityManagerFactory emf;

    public MovieDAO(EntityManagerFactory emf) {
        this.emf = emf;
    }

    @Override
    public Movie create(Movie movie) {
        try (EntityManager em = emf.createEntityManager())  {
            em.getTransaction().begin();

            // 1) Re-attach genres by ID (and validate existence)
            if (movie.getGenres() != null && !movie.getGenres().isEmpty()) {
                Set<Genre> attached = new HashSet<>();
                for (Genre g : movie.getGenres()) {
                    Integer gid = g.getId();
                    if (gid == null) {
                        throw new IllegalArgumentException("Genre id must not be null.");
                    }
                    // Use find(...) to fail fast if genre doesn't exist.
                    Genre managed = em.find(Genre.class, gid);
                    if (managed == null) {
                        throw new jakarta.persistence.EntityNotFoundException(
                                "Genre with id " + gid + " not found in DB");
                    }
                    attached.add(managed);
                }
                movie.setGenres(attached);
            }

            // 2) Persist or merge the movie depending on your ID strategy
            // CASE A: ID GENERATED BY DB (e.g., @GeneratedValue) => do not set movie.id beforehand:
            // em.persist(movie);

            // CASE B: NATURAL/EXTERNAL ID (like TMDB id) that you set yourself:
            // If a movie with same id might already exist, use upsert-like logic:
            if (em.find(Movie.class, movie.getId()) != null) {
                movie = em.merge(movie);     // update existing
            } else {
                em.persist(movie);           // insert new
            }

            em.getTransaction().commit();
            return movie;
        } catch (Exception e) {
            // Log it; don't swallow
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public List<Movie> getAll() {
        try (EntityManager em = emf.createEntityManager())  {
            TypedQuery<Movie> query = em.createQuery("SELECT m FROM Movie m", Movie.class);
            return query.getResultList();
        } catch (Exception e)   {
            e.getMessage();
            return null;
        }
    }

    @Override
    public Movie getById(Integer id) {
        try (EntityManager em = emf.createEntityManager())  {
            Movie movie = em.find(Movie.class, id);
            return movie;
        } catch (Exception e) {
            e.getMessage();
            return null;
        }
    }

    @Override
    public Movie update(Movie movie) {
        try(EntityManager em = emf.createEntityManager())   {
            em.getTransaction().begin();
            Movie updateMovie = em.merge(movie);
            em.getTransaction().commit();
            em.close();
            return updateMovie;
        } catch (Exception e) {
            e.getMessage();
            return null;
        }
    }

    @Override
    public boolean delete(Integer id) {
        try(EntityManager em = emf.createEntityManager()) {
            em.getTransaction().begin();
            Movie removeMovie = getById(id);
            em.remove(removeMovie);
            em.getTransaction().commit();
            return true;
        } catch (Exception e) {
            e.getMessage();
            return false;
        }
    }
}
